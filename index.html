<p><head> <br />
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css"></p>

<!-- jQuery library -->

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>

<!-- Latest compiled JavaScript -->

<script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>

<p></head>
<body> </p>

<div class=container>
<div class="col-sm-8 col-sm-offset-2">
# Typeclasses to break code

## Context

Lately I'm working on a project of mine *mootzoo*. It's a REST server on a sqlite DB and it happens the protocol is growing. 

I splitted the protocol in half. Put requests and Get requests. Put requests are easier as they return (), letting aside the failures which are not in the type.

Easy like

    data Put
        = Boot Mail String  
        | Invite Login Mail String
        | Logout Login String
        | Reminds Mail String
        | Migrate Login Mail String
        | New Login Attach String
        | Retract Login MessageId
        | Leave Login Dispose MessageId
        | Vote Login MessageId Bool
        .....

Well, it happened I added some more features, and I'm not sure this is over.

The main point here is that each module now exports some functions which we can simplify being in IO.

module *Users* exporting 

    boot :: Mail -> String -> IO ()
    invite :: Login -> Mail -> String -> IO ()
    ...

module *Messages* exporting

    new :: Login -> Mail -> String -> IO ()
    ...

module *Voting* exporting

    vote :: Login -> MessageId -> Bool -> IO ()

Back to module *Protocol*  which implements the big

    Put -> IO ()

importing all necessary functions from the other modules.

It's obvious this thing is not any modular.

## Solution

We need a **typeclass**!

    class Put a where
      put :: a -> IO ()

Now each module declares a datatype with its part of the protocol and exports its put functions and *Protocol* is gone.

## Getting

Getting is harder. It would be nice if the Get declares its response type and so we have to use GADTs.

    data Get b where
        Conversation :: Login -> MessageId -> Get [Exposed]
        Past :: Login -> MessageId -> Get [Exposed]
        Check :: Login -> Get String
        ...

Now, to split it 

    class Get a b where
      get :: a b -> IO b

module *Messages* will declare

    data MessageGet b where
        Conversation :: Login -> MessageId -> Get [Exposed]
        Past :: Login -> MessageId -> Get [Exposed]
        CountRoots :: String -> Get Integer


but this is not going to work...

    instance Get MessageGet ?

the *b* here is not useful to select an instance, it's just a constraint for us to write more correct functions.

We have to make it disappear in the class ...

    data WGet = WGet (forall b . a b -> IO b)

    class Get a where
      get :: WGet a

We still have to write a type correct function 

    runMessageGet :: MessageGet b -> IO b

to give it to WGet, but we can split the get protocol.

    instance Get MessageGet where
      get = WGet runMessageGet

### Using Get

At the request handler we will construct values like `CountRoots "hello"`  which cannot be fed to `get` but *haskell* works so

    rget :: Get a => a b -> IO b
    rget x = let WGet f = get in f x

and now we can feed `CountRoots "higher rank"` to rget and receive the result of `runMessageGet` wich will be an `IO Integer` to respond



</div>

<p></div>
</body></p>
